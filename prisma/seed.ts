/* eslint-disable no-console */
import { createHash } from 'crypto';

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Generate deterministic hash for consistent IDs
function generateId(content: string): string {
    return createHash('sha256').update(content).digest('hex').substring(0, 16);
}

async function main(): Promise<void> {
    console.log('üå± Starting seed...');

    // Seed levels
    console.log('üìö Seeding levels...');

    const levels = [
        {
            id: generateId('level-junior'),
            key: 'junior',
            nameUk: 'Junior',
            nameEn: 'Junior',
            isActive: true,
            orderIndex: 0
        },
        {
            id: generateId('level-middle'),
            key: 'middle',
            nameUk: 'Middle',
            nameEn: 'Middle',
            isActive: true,
            orderIndex: 1
        },
        {
            id: generateId('level-senior'),
            key: 'senior',
            nameUk: 'Senior',
            nameEn: 'Senior',
            isActive: true,
            orderIndex: 2
        }
    ];

    for (const level of levels) {
        await prisma.level.upsert({
            where: { key: level.key },
            update: {
                id: level.id,
                nameUk: level.nameUk,
                nameEn: level.nameEn,
                isActive: level.isActive,
                orderIndex: level.orderIndex
            },
            create: level
        });
        console.log(`‚úÖ Level "${level.nameEn}" seeded`);
    }

    // Seed subjects
    console.log('üìö Seeding subjects...');

    const subjects = [
        {
            id: generateId('subject-frontend'),
            nameUk: 'Front-End —Ä–æ–∑—Ä–æ–±–Ω–∏–∫',
            nameEn: 'Front-End Developer',
            descriptionUk: '–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫–∏—Ö —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ñ–≤ —Ç–∞ –∫–ª—ñ—î–Ω—Ç—Å—å–∫–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –≤–µ–±-–¥–æ–¥–∞—Ç–∫—ñ–≤',
            descriptionEn: 'Creating user interfaces and client-side web applications',
            isActive: true
        },
        {
            id: generateId('subject-backend'),
            nameUk: 'Backend —Ä–æ–∑—Ä–æ–±–∫–∞',
            nameEn: 'Backend Development',
            descriptionUk: '–°–µ—Ä–≤–µ—Ä–Ω–∞ —Ä–æ–∑—Ä–æ–±–∫–∞, API, –±–∞–∑–∏ –¥–∞–Ω–∏—Ö —Ç–∞ –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞',
            descriptionEn: 'Server-side development, APIs, databases and architecture',
            isActive: true
        },
        {
            id: generateId('subject-devops'),
            nameUk: 'DevOps',
            nameEn: 'DevOps',
            descriptionUk: '–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω–Ω—è, CI/CD, –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ç–∞ —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞',
            descriptionEn: 'Deployment automation, CI/CD, monitoring and infrastructure',
            isActive: true
        },
        {
            id: generateId('subject-algorithms'),
            nameUk: '–ê–ª–≥–æ—Ä–∏—Ç–º–∏ —Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö',
            nameEn: 'Algorithms and Data Structures',
            descriptionUk: '–û—Å–Ω–æ–≤–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö —Ç–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –æ–±—á–∏—Å–ª–µ–Ω—å',
            descriptionEn: 'Fundamentals of algorithms, data structures and computational complexity',
            isActive: true
        }
    ];

    for (const subject of subjects) {
        await prisma.subject.upsert({
            where: { id: subject.id },
            update: {
                nameUk: subject.nameUk,
                nameEn: subject.nameEn,
                descriptionUk: subject.descriptionUk,
                descriptionEn: subject.descriptionEn,
                isActive: subject.isActive
            },
            create: subject
        });
        console.log(`‚úÖ Subject "${subject.nameEn}" seeded`);
    }

    // Seed books
    console.log('üìñ Seeding books...');

    const books = [
        {
            id: generateId('book-javascript-frontend'),
            titleUk: 'Javascript –¥–ª—è Front-End —Ä–æ–∑—Ä–æ–±–Ω–∏–∫–∞',
            titleEn: 'Javascript for Front-End Developer',
            descriptionUk: '–ü–æ–≤–Ω–∏–π –∫—É—Ä—Å JavaScript –¥–ª—è frontend —Ä–æ–∑—Ä–æ–±–∫–∏ –∑ –ø—Ä–∞–∫—Ç–∏—á–Ω–∏–º–∏ –ø—Ä–∏–∫–ª–∞–¥–∞–º–∏ —Ç–∞ –∑–∞–≤–¥–∞–Ω–Ω—è–º–∏',
            descriptionEn: 'Complete JavaScript course for frontend development with practical examples and tasks',
            isActive: true
        }
    ];

    for (const book of books) {
        await prisma.book.upsert({
            where: { id: book.id },
            update: {
                titleUk: book.titleUk,
                titleEn: book.titleEn,
                descriptionUk: book.descriptionUk,
                descriptionEn: book.descriptionEn,
                isActive: book.isActive
            },
            create: book
        });
        console.log(`‚úÖ Book "${book.titleEn}" seeded`);
    }

    // Seed book-subject relations
    console.log('üîó Seeding book-subject relations...');

    const bookSubjectRelations = [
        {
            bookId: generateId('book-javascript-frontend'),
            subjectId: generateId('subject-frontend')
        }
    ];

    for (const relation of bookSubjectRelations) {
        await prisma.bookSubject.upsert({
            where: {
                bookId_subjectId: {
                    bookId: relation.bookId,
                    subjectId: relation.subjectId
                }
            },
            update: {},
            create: relation
        });
        console.log(`‚úÖ Book-Subject relation "${relation.bookId}" - "${relation.subjectId}" seeded`);
    }

    // Seed JavaScript primitives vs objects question
    console.log('‚ùì Seeding questions...');

    const questionId = generateId('question-js-primitives-vs-objects');
    const juniorLevelId = generateId('level-junior');

    const question = await prisma.question.upsert({
        where: { id: questionId },
        update: {
            textUk: "–Ø–∫–∞ –æ—Å–Ω–æ–≤–Ω–∞ –≤—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –º—ñ–∂ –ø—Ä–∏–º—ñ—Ç–∏–≤–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏ —Ç–∞ –æ–±'—î–∫—Ç–∞–º–∏ —É JavaScript?",
            textEn: 'What is the main difference between primitive types and objects in JavaScript?',
            theoryUk:
                "–£ JavaScript **–ø—Ä–∏–º—ñ—Ç–∏–≤–∏** —î –Ω–µ–∑–º—ñ–Ω–Ω–∏–º–∏ (immutable) –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏. –î–æ –Ω–∏—Ö –Ω–∞–ª–µ–∂–∞—Ç—å: `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`. –í–æ–Ω–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ. \n\n**–û–±'—î–∫—Ç–∏** –∂ —î –∑–º—ñ–Ω–Ω–∏–º–∏ (mutable) —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏, —è–∫—ñ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ –∫–æ–ª–∏ –≤–∏ –ø–µ—Ä–µ–¥–∞—î—Ç–µ –æ–±'—î–∫—Ç —É –∑–º—ñ–Ω–Ω—É –∞–±–æ —Ñ—É–Ω–∫—Ü—ñ—é, –≤–∏ —Ñ–∞–∫—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–¥–∞—î—Ç–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –Ω—å–æ–≥–æ, –∞ –Ω–µ –∫–æ–ø—ñ—é —Å–∞–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è.\n\n‚úÖ –û—Å–Ω–æ–≤–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è: –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ –∫–æ–ø—ñ—é—é—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º.",
            theoryEn:
                'In JavaScript, **primitives** are immutable values. They include: `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`. They store the actual value directly.\n\n**Objects**, on the other hand, are mutable structures stored by reference. This means when you assign or pass an object, you are working with its reference, not a separate copy.\n\n‚úÖ Main difference: primitives are copied by value, while objects are copied by reference.',
            isActive: true,
            levelId: juniorLevelId
        },
        create: {
            id: questionId,
            textUk: "–Ø–∫–∞ –æ—Å–Ω–æ–≤–Ω–∞ –≤—ñ–¥–º—ñ–Ω–Ω—ñ—Å—Ç—å –º—ñ–∂ –ø—Ä–∏–º—ñ—Ç–∏–≤–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏ —Ç–∞ –æ–±'—î–∫—Ç–∞–º–∏ —É JavaScript?",
            textEn: 'What is the main difference between primitive types and objects in JavaScript?',
            theoryUk:
                "–£ JavaScript **–ø—Ä–∏–º—ñ—Ç–∏–≤–∏** —î –Ω–µ–∑–º—ñ–Ω–Ω–∏–º–∏ (immutable) –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏. –î–æ –Ω–∏—Ö –Ω–∞–ª–µ–∂–∞—Ç—å: `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`. –í–æ–Ω–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ. \n\n**–û–±'—î–∫—Ç–∏** –∂ —î –∑–º—ñ–Ω–Ω–∏–º–∏ (mutable) —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏, —è–∫—ñ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ –∫–æ–ª–∏ –≤–∏ –ø–µ—Ä–µ–¥–∞—î—Ç–µ –æ–±'—î–∫—Ç —É –∑–º—ñ–Ω–Ω—É –∞–±–æ —Ñ—É–Ω–∫—Ü—ñ—é, –≤–∏ —Ñ–∞–∫—Ç–∏—á–Ω–æ –ø–µ—Ä–µ–¥–∞—î—Ç–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –Ω—å–æ–≥–æ, –∞ –Ω–µ –∫–æ–ø—ñ—é —Å–∞–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–Ω—è.\n\n‚úÖ –û—Å–Ω–æ–≤–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è: –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ –∫–æ–ø—ñ—é—é—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º.",
            theoryEn:
                'In JavaScript, **primitives** are immutable values. They include: `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`. They store the actual value directly.\n\n**Objects**, on the other hand, are mutable structures stored by reference. This means when you assign or pass an object, you are working with its reference, not a separate copy.\n\n‚úÖ Main difference: primitives are copied by value, while objects are copied by reference.',
            isActive: true,
            levelId: juniorLevelId
        }
    });

    console.log(`‚úÖ Question "${question.textEn}" seeded`);

    // Seed answers for the question
    console.log('üí° Seeding answers...');

    const answers = [
        {
            id: generateId('answer-js-primitives-stored-by-value'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º.",
            textEn: 'Primitives are stored by value, while objects are stored by reference.',
            isCorrect: true,
            theoryUk: "–¶–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å: —É –≤–∏–ø–∞–¥–∫—É –∑ –ø—Ä–∏–º—ñ—Ç–∏–≤–∞–º–∏ –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —Å–∞–º–µ –∑–Ω–∞—á–µ–Ω–Ω—è, –∞ –æ–±'—î–∫—Ç–∏ –ø–µ—Ä–µ–¥–∞—é—Ç—å—Å—è —á–µ—Ä–µ–∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.",
            theoryEn: 'This is the correct answer: primitives store the actual value, while objects are passed by reference.',
            orderIndex: 1
        },
        {
            id: generateId('answer-js-primitives-mutable-objects-immutable'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ —î –∑–º—ñ–Ω–Ω–∏–º–∏, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –Ω–µ–∑–º—ñ–Ω–Ω–∏–º–∏.",
            textEn: 'Primitives are mutable, while objects are immutable.',
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –ø–æ–º–∏–ª–∫–∞: —É—Å–µ –Ω–∞–≤–ø–∞–∫–∏. –ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –Ω–µ–∑–º—ñ–Ω–Ω—ñ, –∞ –æ–±'—î–∫—Ç–∏ –º–æ–∂–Ω–∞ –∑–º—ñ–Ω—é–≤–∞—Ç–∏.",
            theoryEn: "‚ùå Incorrect: it's the opposite. Primitives are immutable, while objects are mutable.",
            orderIndex: 2
        },
        {
            id: generateId('answer-js-objects-direct-primitives-reference'),
            questionId: questionId,
            textUk: "–û–±'—î–∫—Ç–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞–ø—Ä—è–º—É, –∞ –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ ‚Äî –ø–æ—Å–∏–ª–∞–Ω–Ω—è.",
            textEn: 'Objects store values directly, while primitives store references.',
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –ø–æ–º–∏–ª–∫–∞: –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–∞–ø—Ä—è–º—É, –æ–±'—î–∫—Ç–∏ ‚Äî –ª–∏—à–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.",
            theoryEn: '‚ùå Incorrect: primitives store values directly, while objects store references.',
            orderIndex: 3
        },
        {
            id: generateId('answer-js-primitives-constructor-objects-direct'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ —Å—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ.",
            textEn: 'Primitives are created using constructors, while objects are created directly.',
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –ø–æ–º–∏–ª–∫–∞: –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ —Å—Ç–≤–æ—Ä—é—é—Ç—å—Å—è –ª—ñ—Ç–µ—Ä–∞–ª–∞–º–∏ (`42`, `'text'`), –∞ –æ–±'—î–∫—Ç–∏ ‚Äî —á–µ—Ä–µ–∑ –ª—ñ—Ç–µ—Ä–∞–ª–∏ `{}` –∞–±–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ `new Object()`.",
            theoryEn:
                "‚ùå Incorrect: primitives are usually created with literals (`42`, `'text'`), while objects can be created with literals `{}` or constructors like `new Object()`.",
            orderIndex: 4
        },
        {
            id: generateId('answer-js-primitives-no-methods-objects-have'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –Ω–µ –º–∞—é—Ç—å –º–µ—Ç–æ–¥—ñ–≤, –∞ –æ–±'—î–∫—Ç–∏ –º–∞—é—Ç—å.",
            textEn: "Primitives don't have methods, while objects do.",
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –Ω–µ—Ç–æ—á–Ω—ñ—Å—Ç—å: –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ –º–∞—é—Ç—å –º–µ—Ç–æ–¥–∏ –∑–∞–≤–¥—è–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–º—É boxing —É —Ç–∏–º—á–∞—Å–æ–≤—ñ –æ–±'—î–∫—Ç–∏ (`'text'.toUpperCase()`).",
            theoryEn: "‚ùå Not entirely correct: primitives do have methods via automatic boxing into temporary objects (`'text'.toUpperCase()`).",
            orderIndex: 5
        },
        {
            id: generateId('answer-js-objects-always-more-memory'),
            questionId: questionId,
            textUk: "–û–±'—î–∫—Ç–∏ –∑–∞–≤–∂–¥–∏ –∑–∞–π–º–∞—é—Ç—å –±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ –Ω—ñ–∂ –ø—Ä–∏–º—ñ—Ç–∏–≤–∏.",
            textEn: 'Objects always take more memory than primitives.',
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –ø–µ—Ä–µ–±—ñ–ª—å—à–µ–Ω–Ω—è: —Ö–æ—á–∞ –æ–±'—î–∫—Ç–∏ –∑–∞–∑–≤–∏—á–∞–π –≤–∞–∂—á—ñ, —Ç–æ—á–Ω–µ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –ø–∞–º'—è—Ç—ñ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥–≤–∏–≥—É–Ω–∞ JS.",
            theoryEn: '‚ùå This is an oversimplification: objects are usually heavier, but actual memory usage depends on the JS engine implementation.',
            orderIndex: 6
        },
        {
            id: generateId('answer-js-primitives-compared-by-value'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –∑–∞–≤–∂–¥–∏ –ø–æ—Ä—ñ–≤–Ω—é—é—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –∑–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º.",
            textEn: 'Primitives are always compared by value, while objects are compared by reference.',
            isCorrect: true,
            theoryUk: "‚úÖ –¶–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –æ—Å–æ–±–ª–∏–≤—ñ—Å—Ç—å: –¥–≤–∞ —Ä—ñ–∑–Ω—ñ –æ–±'—î–∫—Ç–∏ –∑ –æ–¥–Ω–∞–∫–æ–≤–∏–º–∏ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏ –Ω–µ –±—É–¥—É—Ç—å —Ä—ñ–≤–Ω—ñ (`{a:1} !== {a:1}`).",
            theoryEn: '‚úÖ This is correct: two different objects with the same properties are not equal (`{a:1} !== {a:1}`).',
            orderIndex: 7
        },
        {
            id: generateId('answer-js-primitives-spread-clone-objects-not'),
            questionId: questionId,
            textUk: "–ü—Ä–∏–º—ñ—Ç–∏–≤–∏ –º–æ–∂–Ω–∞ –∫–ª–æ–Ω—É–≤–∞—Ç–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º spread, –∞ –æ–±'—î–∫—Ç–∏ ‚Äî –Ω—ñ.",
            textEn: 'Primitives can be cloned using the spread operator, but objects cannot.',
            isCorrect: false,
            theoryUk:
                "‚ùå –ù–µ–ø—Ä–∞–≤–¥–∞: spread (`...`) –º–æ–∂–Ω–∞ –∑–∞—Å—Ç–æ—Å–æ–≤—É–≤–∞—Ç–∏ –¥–æ –æ–±'—î–∫—Ç—ñ–≤ (`{...obj}`) —Ç–∞ –º–∞—Å–∏–≤—ñ–≤, –∞–ª–µ –≤—ñ–Ω –Ω–µ –∫–ª–æ–Ω—É—î –ø—Ä–∏–º—ñ—Ç–∏–≤–∏, –±–æ –≤–æ–Ω–∏ –π —Ç–∞–∫ –∫–æ–ø—ñ—é—é—Ç—å—Å—è –∑–∞ –∑–Ω–∞—á–µ–Ω–Ω—è–º.",
            theoryEn: "‚ùå Incorrect: spread (`...`) works on objects (`{...obj}`) and arrays, primitives don't need cloning since they are copied by value.",
            orderIndex: 8
        },
        {
            id: generateId('answer-js-primitives-seven-types-list'),
            questionId: questionId,
            textUk: '–î–æ –ø—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤ –≤—ñ–¥–Ω–æ—Å—è—Ç—å—Å—è: string, number, boolean, undefined, symbol, null, bigint.',
            textEn: 'Primitives include: string, number, boolean, undefined, symbol, null, bigint.',
            isCorrect: true,
            theoryUk: '‚úÖ –¶–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –ø–µ—Ä–µ–ª—ñ–∫ —É—Å—ñ—Ö 7 –ø—Ä–∏–º—ñ—Ç–∏–≤–Ω–∏—Ö —Ç–∏–ø—ñ–≤ —É JS.',
            theoryEn: '‚úÖ This is the correct list of all 7 primitive types in JS.',
            orderIndex: 9
        },
        {
            id: generateId('answer-js-objects-always-new-keyword'),
            questionId: questionId,
            textUk: "–û–±'—î–∫—Ç–∏ –∑–∞–≤–∂–¥–∏ —Å—Ç–≤–æ—Ä—é—é—Ç—å—Å—è —á–µ—Ä–µ–∑ –∫–ª—é—á–æ–≤–µ —Å–ª–æ–≤–æ new.",
            textEn: 'Objects are always created using the new keyword.',
            isCorrect: false,
            theoryUk: "‚ùå –¶–µ –ø–æ–º–∏–ª–∫–∞: –æ–±'—î–∫—Ç–∏ –º–æ–∂–Ω–∞ —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –ª—ñ—Ç–µ—Ä–∞–ª–∞–º–∏ `{}`, –º–∞—Å–∏–≤–∞–º–∏ `[]` —á–∏ –Ω–∞–≤—ñ—Ç—å —Ñ—É–Ω–∫—Ü—ñ—è–º–∏, –Ω–µ —Ç—ñ–ª—å–∫–∏ —á–µ—Ä–µ–∑ `new`.",
            theoryEn: '‚ùå Incorrect: objects can be created with literals `{}`, arrays `[]`, or functions, not only with `new`.',
            orderIndex: 10
        }
    ];

    for (const answer of answers) {
        await prisma.answer.upsert({
            where: { id: answer.id },
            update: {
                textUk: answer.textUk,
                textEn: answer.textEn,
                isCorrect: answer.isCorrect,
                theoryUk: answer.theoryUk,
                theoryEn: answer.theoryEn,
                orderIndex: answer.orderIndex
            },
            create: answer
        });
        console.log(`‚úÖ Answer ${answer.orderIndex} seeded`);
    }

    // Add question to book
    console.log('üìñ Adding question to book...');

    const bookId = generateId('book-javascript-frontend');

    await prisma.bookQuestion.upsert({
        where: {
            bookId_questionId: {
                bookId: bookId,
                questionId: questionId
            }
        },
        update: {
            orderIndex: 1
        },
        create: {
            bookId: bookId,
            questionId: questionId,
            orderIndex: 1
        }
    });

    console.log('‚úÖ Question added to book');
    console.log('üéâ Seed completed!');
}

main()
    .catch((e) => {
        console.error('‚ùå Seed failed:', e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });
